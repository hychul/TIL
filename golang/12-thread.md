#Go의 Thread

스레드는 튜링머신에서 명령어 적어놓은 종이에서 유래된 말이다. 튜링 머신은 긴 종이 테이프를 한쪽 방향으로 읽으면서 적혀진 명령어를 실행했다. 때문에 과거의 컴퓨터는 한번에 하나의 스레드만 실행할 수 있었다.

하지만 현대로 넘어오면서 여러 스레드를 실행할 수 있게 되었다. 튜링머신과 같이 종이를 매번 갈아 끼워야하는 물리적 제약이 없어지고, 전자적으로 스레드를 빠르게 전환할 수 있기 때문에 CPU의 코어의 갯수가 하나더라도 여러 스레드를 실행하는 것처럼 보이게 되는 것이다.

하지만 이런 스레드를 전환을 시킬때 스레드를 교체하고, 마지막 커서를 기록하는 등의 컨텍스트 스위치<sup>Context Switch</sup> 비용이 발생한다. 때문에 너무 많은 스레드를 만들어 동시에 실행하는 경우 실제 실제 실행보다 스레드 전환에 비용이 더 커질 수 있어 주의해야한다.

Golang에서는 스레드를 고루틴<sup>Goroutine</sup>으로 한번 감싸서 제공한다. Goroutine는 스레드를 잘개 쪼개 사용하면서 스레드의 갯수를 최소한(CPU의 코어 갯수와 비슷하게)으로 관리한다. 컨텍스트 스위칭은 OS 레벨의 스레드에서 발생하기 때문에 고루틴은 스레드에 비해서 컨텍스트 스위칭 비용이 적다.

## Goroutine

고루틴으로 새로운 스레드를 생성하는 것은 컨텍스트 스위칭에서 이점이 있는 것 만큼 `go` 키워드를 통해 쉽게 할 수 있다.

```go
func main() {
    go func1() // 고루틴으로 func1() 함수를 수행

    for i := 0; i < 3; i++ {
        time.Sleep(100 * time.Millisecond)
        fmt.Println("main", i)
    }

    fmt.Scanln();
}

func func1() {
    for i := 0; i < 3; i++ {
        time.Sleep(100 * time.Millisecond)
        fmt.Println("func1", i)
    }
}
```
```terminal
main 0
func1 0
func1 1
main 1
main 2
func1 2
```

## Lock

공유 자원을 사용하는 임계영역에 대한 동기화 이슈를 해결하기 위해 Golang은 `Mutex`라는 구조체로 `Lock()`과 `Unlock()` 함수를 제공한다.

```gof
mutext := &sync.Mutex{}

mutext.Lock()
... // 임계영역
mutext.Unlock()
```

락을 통해 임계 영역에 대한 동기화를 해결할 수 있지만 주의하지 않으면 데드락이 발생할 수 있다. 